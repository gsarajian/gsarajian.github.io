<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>NBAyesian Career Trajectories</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
.navigation ul {
  list-style-type: none;
  text-align: left;
  padding-left: 0;
  padding-bottom: 2em;
}

.navigation li {
  display: inline;
}

.navigation a {
    color: #3366FF;
    text-decoration: none;
}

    
</style>


<script src="NBAyesian Career Trajectories_files/libs/clipboard/clipboard.min.js"></script>
<script src="NBAyesian Career Trajectories_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="NBAyesian Career Trajectories_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="NBAyesian Career Trajectories_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="NBAyesian Career Trajectories_files/libs/quarto-html/popper.min.js"></script>
<script src="NBAyesian Career Trajectories_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="NBAyesian Career Trajectories_files/libs/quarto-html/anchor.min.js"></script>
<link href="NBAyesian Career Trajectories_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="NBAyesian Career Trajectories_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="NBAyesian Career Trajectories_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="NBAyesian Career Trajectories_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="NBAyesian Career Trajectories_files/libs/bootstrap/bootstrap-9e3ffae467580fdb927a41352e75a2e0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">NBAyesian Career Trajectories</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>

        <div class="navigation">
            <ul>
                <li><a href="https://gsarajian.github.io">Home</a></li> //
                <li><a href="https://gsarajian.github.io/projects">Projects</a></li>  //
                <li><a href="https://gsarajian.github.io/research">Research</a></li>  
            </ul>
        </div>


<section id="motivation" class="level2">
<h2 class="anchored" data-anchor-id="motivation">Motivation</h2>
<!-- ![](Screenshots/pts_vs_age_25.png) -->
<p><img src="Screenshots/pts_vs_age_25.png" width="500" height="300"></p>
<p>As part of our <a href="https://github.com/erictleung/statistical-rethinking-book-club">Bayesian Statistics book club</a>, I wanted to demonstrate a use case of Bayesian techniques while familiarizing myself with some of the hierarchical modeling tools in python. Since I had some experience with sabermetrics and wanted to do something slightly different, I settled on the following question.</p>
<section id="how-can-one-model-nba-players-career-trajectories" class="level3">
<h3 class="anchored" data-anchor-id="how-can-one-model-nba-players-career-trajectories">How can one model NBA players’ career trajectories?</h3>
<p>This question has much relevance for players, coaches, general managers, fans, and others. I’ll mostly follow the lead of Jim Albert’s <a href="https://baseballwithr.wordpress.com/2019/11/25/multilevel-modeling-of-obp-trajectories/">excellent blog post</a> on an analogous question for MLB players. Although there are many ways NBA players contribute to their teams’ success, we’ll narrow our scope and only use three bits of information: who the player is, their age, and how many points they scored each season. First let’s grab the data and pare it down to players who played last season and who have played at least two seasons. <!-- in the last 25 years who have played at least 5 seasons in that time frame. --></p>
<div id="f5e305b8-2ecc-452f-8a15-4672fbe886c6" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> nba_api</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># from nba_api.stats.static import teams</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> nba_api.stats.endpoints <span class="im">import</span> playercareerstats</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co"># from nba_api.stats.endpoints import playercareerstats, leaguegamefinder</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
</section>
</section>
<section id="two-wrong-approaches" class="level2">
<h2 class="anchored" data-anchor-id="two-wrong-approaches">Two Wrong Approaches</h2>
<section id="ignoring-who-the-players-are" class="level3">
<h3 class="anchored" data-anchor-id="ignoring-who-the-players-are">Ignoring who the players are</h3>
<p>Let’s look at the average number of points scored by players during last season based on their age. The plot at the top of the page is fit with a <a href="https://en.wikipedia.org/wiki/Local_regression">LOESS</a> model, and for simplicity, we can also fit a quadratic model:</p>
<p><span class="math display">\[Points_i = \beta_0 + \beta_1 Age_i + \beta_2 Age_i^2\]</span></p>
<p>Here’s the plot with a quadratic model.</p>
<p><img src="Screenshots/pts_vs_age_25_quad.png" width="500" height="300"></p>
<p>Without much context, these might be surprising. The LOESS model shows that players continue to score more points on average as they age, and the quadratic model shows a decline, but it shows players continuing to score at a respectable rate, even in their late 30s. This is contrary to what we might expect from older players being less athletic. Why don’t teams fill their rosters with older players who are great at scoring? The issue with that logic is that there’s a <a href="https://en.wikipedia.org/wiki/Survivorship_bias">survivorship bias</a>. The following table, bar chart, and explanation after break it down for us.</p>
<table class="dataframe table table-sm table-striped small">
<thead>
<tr>
<th>
Age
</th>
<th>
Average Points
</th>
<th>
Number of players
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
19
</td>
<td>
289.17
</td>
<td>
6
</td>
</tr>
<tr>
<td>
20
</td>
<td>
422.89
</td>
<td>
18
</td>
</tr>
<tr>
<td>
21
</td>
<td>
457.23
</td>
<td>
31
</td>
</tr>
<tr>
<td>
22
</td>
<td>
399.34
</td>
<td>
47
</td>
</tr>
<tr>
<td>
23
</td>
<td>
464.40
</td>
<td>
52
</td>
</tr>
<tr>
<td>
24
</td>
<td>
361.42
</td>
<td>
78
</td>
</tr>
<tr>
<td>
25
</td>
<td>
443.67
</td>
<td>
63
</td>
</tr>
<tr>
<td>
26
</td>
<td>
449.12
</td>
<td>
51
</td>
</tr>
<tr>
<td>
27
</td>
<td>
614.93
</td>
<td>
43
</td>
</tr>
<tr>
<td>
28
</td>
<td>
578.59
</td>
<td>
37
</td>
</tr>
<tr>
<td>
29
</td>
<td>
563.47
</td>
<td>
34
</td>
</tr>
<tr>
<td>
30
</td>
<td>
979.93
</td>
<td>
14
</td>
</tr>
<tr>
<td>
31
</td>
<td>
486.95
</td>
<td>
21
</td>
</tr>
<tr>
<td>
32
</td>
<td>
579.00
</td>
<td>
20
</td>
</tr>
<tr>
<td>
33
</td>
<td>
557.81
</td>
<td>
16
</td>
</tr>
<tr>
<td>
34
</td>
<td>
577.50
</td>
<td>
8
</td>
</tr>
<tr>
<td>
35
</td>
<td>
797.00
</td>
<td>
10
</td>
</tr>
<tr>
<td>
36
</td>
<td>
523.14
</td>
<td>
7
</td>
</tr>
<tr>
<td>
37
</td>
<td>
839.00
</td>
<td>
4
</td>
</tr>
<tr>
<td>
38
</td>
<td>
90.00
</td>
<td>
2
</td>
</tr>
<tr>
<td>
39
</td>
<td>
243.00
</td>
<td>
3
</td>
</tr>
<tr>
<td>
40
</td>
<td>
637.25
</td>
<td>
4
</td>
</tr>
</tbody>
</table>
<p><img src="Screenshots/pts_vs_age_25_bar.png" width="500" height="300"></p>
<p>We can see there are a lot 20-something year-olds in the league, which is in tune with what we might’ve originally expected. The older ages have high scoring averages because the only players who are that age and are still in the league are stars who are past their peaks but are still good enough to contribute to their teams. Or as I told my class, “if we only looked at players with over 20 years of playing time, the results are pretty skewed since we’re only looking at LeBron James, who isn’t representitve of players.” Here are all the players who were 40 years old last season.</p>
<table class="dataframe table table-sm table-striped small">
<thead>
<tr>
<th>
PLAYER_NAME
</th>
<th>
PTS
</th>
<th>
AGE
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
Chris Paul
</td>
<td>
723
</td>
<td>
40
</td>
</tr>
<tr>
<td>
LeBron James
</td>
<td>
1710
</td>
<td>
40
</td>
</tr>
<tr>
<td>
P.J. Tucker
</td>
<td>
9
</td>
<td>
40
</td>
</tr>
<tr>
<td>
Taj Gibson
</td>
<td>
107
</td>
<td>
40
</td>
</tr>
</tbody>
</table>
<p>Surely, if we looked at <em>all</em> 40-year-olds who have played in the NBA and forced them back into the league, the average scoring for 40-year-olds would be much smaller.</p>
</section>
<section id="individual-models" class="level3">
<h3 class="anchored" data-anchor-id="individual-models">Individual models</h3>
<p>So how can we try to account for this and model career trajectories? The other end of the spectrum would be to ignore similarities across players and to fit individual models for each player. We don’t have as much data for younger players, so I’d be hesitant to fit a LOESS model, and a quadratic model might seem like a good first approximation. A quadratic model looks as follows:</p>
<p><span class="math display">\[Points_i = \beta_{0,i} + \beta_{1,i} Age_i + \beta_{2,i} Age_i^2 \]</span></p>
<p>However, even with a lightweight model, this would be overfitting. For example, here are quadratic fits to all players who received an MVP vote in the ’24-’25 season.</p>
<iframe src="Screenshots/player_age_curves.html" width="100%" height="500">
</iframe>
<p>Though some of the quadratic curves fit the data well, some of them predict unrealistic trajectories. In particular, the parabolas for Shai Gilgeous-Alexander, Cade Cunningham, and Evan Mobley all open upwards, which doesn’t make sense since in reality, they’ll eventually start to decline. Our choice in a quadratic model can partially be blamed, but so can our choice of fitting a unique model for each individual. By fitting individual models, we’re missing out on relationships between the parameters of different players. Bayesian statistics can help us resolve this.</p>
<p>Instead of fitting individual models, we can use a <a href="https://en.wikipedia.org/wiki/Multilevel_model">multilevel model</a>. These types of models are good for data that can be grouped at multiple levels. In this case, each datapoint consists of a player, his age, and how many points he scored. Our first type of model ignored the relationships at the player level, though this is important; players perform at different levels, with different peaks and improvement/decline rates. The second type of model we fit ignored relationships across the players at different ages, and this information is useful because biology and experience lead to players having similarly shaped trajectories.</p>
<p>The Bayesian philosophy is as follows. We can again use the framework of the quadratic model</p>
<p><span class="math display">\[Points_i = \beta_{0,i} + \beta_{1,i} Age_i + \beta_{2,i} Age_i^2 \]</span></p>
<p>However, this time, we assume that the coefficients <span class="math inline">\(\beta_{0,i}\)</span> come from a distribution, as do the <span class="math inline">\(\beta_{1,i}\)</span> and <span class="math inline">\(\beta_{2,i}\)</span>. These assumptions impose a regularization on the coefficients and ensure that they don’t solely consider the individual player, but rather also overall scoring vs.&nbsp;age trends. The assumptions look like</p>
<p><span class="math display">\[\beta_{0,i} \sim N(\mu_0, \sigma_0^2)\]</span> <span class="math display">\[\beta_{1,i} \sim N(\mu_1, \sigma_1^2)\]</span> <span class="math display">\[\beta_{2,i} \sim N(\mu_2, \sigma_2^2)\]</span></p>
<p>Here’s what the code looks like as well as a plot of the same players’ trajectories using the hierarchical model.</p>
<iframe src="Screenshots/hierarchical_player_age_curves.html" width="100%" height="500">
</iframe>
<p>We immediately see that now, all the trajectories are downward opening, which matches what we’d expect from what we know about athletes’ careers. I think this might be overfitting a little bit because many of the players’ curves decline rather steeply. This analysis included all players who played in the ’24-’25 season, and we’re comparing so it includes hundreds of players who won’t have as long of careers or high of peaks as the MVP candidates we’re looking at here. One way we can assuage this overfitting is by relaxing our priors, increasing the hyperparameters for <span class="math inline">\(\sigma_i\)</span>.</p>
<!-- New Years Resolution
- Read and write more
- Visit friends and family! SF, SB, Costa Rica, Peru, etc.
- Moved by March (me & Chestnut)
- Get even more shots up -->
<section id="further-approaches-and-questions" class="level4">
<h4 class="anchored" data-anchor-id="further-approaches-and-questions">Further approaches and questions</h4>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>